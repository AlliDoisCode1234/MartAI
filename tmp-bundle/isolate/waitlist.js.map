{
  "version": 3,
  "sources": ["../convex/waitlist.ts"],
  "sourcesContent": ["import { mutation, query } from './_generated/server';\r\nimport { v } from 'convex/values';\r\nimport { api } from './_generated/api';\r\n\r\n/**\r\n * Waitlist Mutations & Queries\r\n *\r\n * Component Hierarchy:\r\n * \u2514\u2500\u2500 Landing Page (phoo.ai) \u2192 WaitlistForm \u2192 joinWaitlist mutation\r\n *\r\n * Lead capture for phoo.ai pre-launch waitlist.\r\n * Creates BOTH:\r\n * - Waitlist entry (for tracking/admin)\r\n * - User record (for lifetime value tracking)\r\n *\r\n * On signup, syncs to HubSpot CRM for sales follow-up.\r\n */\r\n\r\n/**\r\n * Join the waitlist with email and optional tracking metadata.\r\n * Idempotent: if email already exists, returns existing entry ID.\r\n * Creates a user record with acquisitionSource='waitlist_beta'.\r\n * Triggers HubSpot sync for new signups.\r\n */\r\nexport const joinWaitlist = mutation({\r\n  args: {\r\n    email: v.string(),\r\n    source: v.optional(v.string()),\r\n    metadata: v.optional(\r\n      v.object({\r\n        referrer: v.optional(v.string()),\r\n        utmSource: v.optional(v.string()),\r\n        utmMedium: v.optional(v.string()),\r\n        utmCampaign: v.optional(v.string()),\r\n        userAgent: v.optional(v.string()),\r\n      })\r\n    ),\r\n  },\r\n  handler: async (ctx, args) => {\r\n    // Validate email format\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    if (!emailRegex.test(args.email)) {\r\n      throw new Error('Invalid email format');\r\n    }\r\n\r\n    // Normalize email to lowercase\r\n    const normalizedEmail = args.email.toLowerCase().trim();\r\n\r\n    // Check for existing waitlist entry (idempotent)\r\n    const existingWaitlist = await ctx.db\r\n      .query('waitlist')\r\n      .withIndex('by_email', (q) => q.eq('email', normalizedEmail))\r\n      .first();\r\n\r\n    if (existingWaitlist) {\r\n      // Already on waitlist - return existing ID\r\n      return { id: existingWaitlist._id, alreadyExists: true };\r\n    }\r\n\r\n    const now = Date.now();\r\n\r\n    // Create new waitlist entry\r\n    const waitlistId = await ctx.db.insert('waitlist', {\r\n      email: normalizedEmail,\r\n      source: args.source ?? 'phoo.ai',\r\n      metadata: args.metadata,\r\n      status: 'pending',\r\n      createdAt: now,\r\n    });\r\n\r\n    // Check if user record already exists (e.g., previous organic signup)\r\n    const existingUser = await ctx.db\r\n      .query('users')\r\n      .withIndex('email', (q) => q.eq('email', normalizedEmail))\r\n      .first();\r\n\r\n    let userId = existingUser?._id;\r\n\r\n    if (!existingUser) {\r\n      // Create user record with acquisition tracking\r\n      // This makes waitlist signups \"real users\" from day one\r\n      // Beta users get solo tier - betaExpiresAt set when onboarding completes\r\n      userId = await ctx.db.insert('users', {\r\n        email: normalizedEmail,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n        role: 'user',\r\n        accountStatus: 'inactive', // Activate when they complete onboarding\r\n        onboardingStatus: 'not_started',\r\n        acquisitionSource: 'waitlist_beta',\r\n        acquisitionDate: now,\r\n        acquisitionMetadata: {\r\n          utmSource: args.metadata?.utmSource,\r\n          utmMedium: args.metadata?.utmMedium,\r\n          utmCampaign: args.metadata?.utmCampaign,\r\n          referrer: args.metadata?.referrer,\r\n          waitlistId: waitlistId,\r\n        },\r\n        // Beta user fields - skip pricing/payment in onboarding\r\n        // betaExpiresAt set when onboarding completes (6 months from then)\r\n        isBetaUser: true,\r\n        membershipTier: 'solo',\r\n      });\r\n    }\r\n\r\n    // Schedule HubSpot sync (non-blocking, fire-and-forget)\r\n    await ctx.scheduler.runAfter(0, api.integrations.hubspot.syncWaitlistToHubspot, {\r\n      email: normalizedEmail,\r\n      source: args.source ?? 'phoo.ai',\r\n      utmSource: args.metadata?.utmSource,\r\n      utmMedium: args.metadata?.utmMedium,\r\n      utmCampaign: args.metadata?.utmCampaign,\r\n    });\r\n\r\n    return { id: waitlistId, userId, alreadyExists: false };\r\n  },\r\n});\r\n\r\n/**\r\n * Get waitlist count for social proof on landing page.\r\n * Returns approximate count (no PII exposed).\r\n */\r\nexport const getWaitlistCount = query({\r\n  args: {},\r\n  handler: async (ctx) => {\r\n    const entries = await ctx.db.query('waitlist').collect();\r\n    return { count: entries.length };\r\n  },\r\n});\r\n\r\n/**\r\n * Admin: Get all waitlist entries (super_admin only).\r\n * For internal use in admin dashboard.\r\n */\r\nexport const listWaitlistEntries = query({\r\n  args: {\r\n    limit: v.optional(v.number()),\r\n  },\r\n  handler: async (ctx, args) => {\r\n    // Note: Add authentication check when integrating with admin\r\n    const limit = args.limit ?? 100;\r\n    const entries = await ctx.db\r\n      .query('waitlist')\r\n      .withIndex('by_created')\r\n      .order('desc')\r\n      .take(limit);\r\n\r\n    return entries;\r\n  },\r\n});\r\n"],
  "mappings": "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",
  "names": ["init_values", "init_api", "joinWaitlist", "mutation", "v", "__name", "ctx", "args", "normalizedEmail", "existingWaitlist", "q", "now", "waitlistId", "existingUser", "userId", "api", "getWaitlistCount", "query", "listWaitlistEntries", "limit"]
}
